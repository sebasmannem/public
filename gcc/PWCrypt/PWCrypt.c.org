#define _GNU_SOURCE         /* See feature_test_macros(7) */
#include <stdio.h>
//int asprintf(char **strp, const char *fmt, ...);
//int vasprintf(char **strp, const char *fmt, va_list ap);

//#define _XOPEN_SOURCE       /* See feature_test_macros(7) */
#include <unistd.h>
//char *crypt(const char *key, const char *salt);
//char *crypt_r(const char *key, const char *salt,
//              struct crypt_data *data);
//void encrypt(char block[64], int edflag);
//int gethostname(char *name, size_t namelen);

#include <stdlib.h>
//void setkey(const char *key);
//int rand(void);
//int rand_r(unsigned int *seedp);
//void srand(unsigned int seed);

#include <crypt.h>
//void setkey_r(const char *key, struct crypt_data *data);
//void encrypt_r(char *block, int edflag, struct crypt_data *data);

#include <string.h>
//size_t strlen(const char *s);

#include <time.h>
//time_t time(time_t *tloc);

#include <openssl/evp.h>
//int EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type, ENGINE *impl, unsigned char *key, unsigned char *iv);

char *substring(char *string, int start, int length)
{
  char *tmp;
  int stringlength;
  stringlength = strlen(string);

  if (start > stringlength)
    {
    start = stringlength;
    length = 0;
    }
  if (start + length > stringlength)
    {length = stringlength - start;}

  tmp=(char *) malloc (length+1);
  strncpy(tmp,string+start,length);
  tmp[length]=0;

  return tmp;
}


char *RndString(int length, char *ValidChars)
{
  int i,val;
  //Temp for return value
  char *Temp;
  Temp = (char *) malloc (length);
 
  //Seed number for rand()
  srand((unsigned int) time(0) + getpid());
 
  //ASCII characters 33 to 126
  for (i=0 ; i< length; i++)
    {
    val = rand() % strlen(ValidChars);
    Temp[i] = ValidChars[val];
    srand(rand());
    }
 
  return Temp;
}

int str_encrypt(char *in, unsigned char *out, unsigned char *key, unsigned char *iv)
  {
  out =  (unsigned char *) malloc (1024);
  int outlen, tmplen;
//  unsigned char key[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
//  unsigned char iv[] = {1,2,3,4,5,6,7,8};
  EVP_CIPHER_CTX ctx;
  EVP_CIPHER_CTX_init(&ctx);
  EVP_EncryptInit_ex(&ctx, EVP_bf_cbc(), NULL, key, iv);

  if(!EVP_EncryptUpdate(&ctx, out, &outlen, (const unsigned char*)in, strlen(in)))
    {
    /* Error */
    return 0;
    }
 /* Buffer passed to EVP_EncryptFinal() must be after data just
  * 
  * encrypted to avoid overwriting it.
  *                                 
  */
  if(!EVP_EncryptFinal_ex(&ctx, out + outlen, &tmplen))
    {
    /* Error */
   return 0;
    }
  outlen += tmplen;
  EVP_CIPHER_CTX_cleanup(&ctx);
  out = (unsigned char *) realloc (out,outlen);
//  printf("out=%s", out);
  return outlen;

  }

int str_decrypt(unsigned char *in, char *out, unsigned char *key, unsigned char *iv)
  {
  out =  (unsigned char *) malloc (1024);
  int outlen, tmplen;
//  unsigned char key[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
//  unsigned char iv[] = {1,2,3,4,5,6,7,8};
  EVP_CIPHER_CTX ctx;
  EVP_CIPHER_CTX_init(&ctx);
  EVP_DecryptInit_ex(&ctx, EVP_bf_cbc(), NULL, key, iv);

  if (!EVP_DecryptUpdate(&ctx, out, &outlen, (const unsigned char*)in, strlen((char *)in)))
    {
    /* Error */
    return 0;
    }
  /* Buffer passed to EVP_EncryptFinal() must be after data just
   * 
   * encrypted to avoid overwriting it.
   *                                 
   */
  if (!EVP_DecryptFinal_ex(&ctx, out + outlen, &tmplen))
    {
    /* Error */
    return 0;
    }
  outlen += tmplen;
  EVP_CIPHER_CTX_cleanup(&ctx);
  out = (char *) realloc (out,outlen);
  //  printf("out=%s", out);
  return outlen;
  }

int main (int argc, char *argv[])
{
  int i, val;
  char *key, *Hkey, *Rnd, *HSalt, *tmp, *password, *hostname, *username;

  char *ReadableChars;

 if (argc < 2)
    {
    //Ask
    //    uname = (char *) malloc (2);
    //    printf("Please specify string to encrypt (max 20 characters): ");
    //    gets(str);
    //    scanf ("%20s", str);
    puts("No parameter was specified.\nPlease specify data to encrypt...\nNow exiting.");
    return 1;
  }

  OpenSSL_add_all_digests();

  ReadableChars = (char *) malloc (64);
  for (i=0 ; i< 62; i++)
    {
    if (i < 10)
      {ReadableChars[i] = i + 48;} //0-9
    else if (i < 36)
      {ReadableChars[i] = i + 55;} //A-Z
    else
      {ReadableChars[i] = i + 61;} //a-z
    }
  ReadableChars[62] = 0;

  hostname = (char *) malloc (1024);
  hostname[1023] = '\0';
  gethostname(hostname, 1023);
//  printf("len=%i",strlen(hostname));
  hostname = realloc(hostname,strlen(hostname));

  username = getenv("USER");

  // First of all, generated Salt for SHA-512 HASH with seed depending on executable name.
  // Salt is generated and therefore will not be printed when strings program is used.
  // Salt will change if the program name is changed (mv, ln, ln -s, whatever).
  HSalt = (char *) malloc (16);
  for (i=0 ; i< 16; i++)
    {
    val = (i * 11) % strlen(ReadableChars);
    HSalt[i] = ReadableChars[val];
    }
//  printf ("HSaltPre=%s\n", HSalt);

  asprintf(&tmp, "$5$%s$",HSalt); //Create tmp salt to create salt...
//  HSalt = substring(crypt(HSalt, tmp),strlen(tmp),16);  //Create salt from tmp salt and all the available chars for Random generation (just some bogus).
  HSalt = crypt(hostname, tmp);
//  printf ("HSaltPost=%s\n", HSalt);
 
  HSalt = substring(HSalt,strlen(tmp),16);
  asprintf(&HSalt, "$5$%s$", HSalt);//Add header to salt
  printf ("HSaltPost2=%s\n", HSalt);

  key = argv[1];
  Hkey = crypt(key, HSalt);
  Hkey = substring(Hkey,strlen(HSalt),strlen(Hkey));

  Rnd = RndString(20, ReadableChars);
  if (argc > 2)
    {
    password = argv[2];
    unsigned char *cryptkey;
    cryptkey = (unsigned char*) HSalt;
    unsigned char cryptiv[] = {1,2,3,4,5,6,7,8};
    unsigned char *HPassword;
    printf("PasswordPre:%s\n", password);
    i = str_encrypt(password, HPassword, cryptkey, cryptiv);
    i = str_decrypt(HPassword, password, cryptkey, cryptiv);
    printf("PasswordPost:%s\n", password);

//    printf("%s->%s (%i)\n",password,HPassword,i);
    }
  else
    {password = "";}

  printf("Hostname=%s\nUsername=%s\nReadableChars=%s\nkey=%s\nHkey=%s\nRnd=%s\nPassword=%s\n", hostname, username, ReadableChars, key, Hkey, Rnd, password);
  free(Rnd);
  free(ReadableChars);
  free(hostname);
  free(HSalt);

  EVP_cleanup();
  return 0;
} 
