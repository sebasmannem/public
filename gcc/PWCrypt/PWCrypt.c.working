#define _GNU_SOURCE         /* See feature_test_macros(7) */
#include <stdio.h>
//int asprintf(char **strp, const char *fmt, ...);
//int fprintf(FILE *stream, const char *format, ...);
//int fscanf(FILE *stream, const char *format, ...);
//int printf(const char *format, ...);
//int puts(const char *s);

#include <unistd.h>
//char *crypt(const char *key, const char *salt);
//int gethostname(char *name, size_t namelen);

#include <stdlib.h>
//int rand(void);
//void srand(unsigned int seed);
//void *malloc(size_t size);
//void free(void *ptr);
//void *realloc(void *ptr, size_t size);

#include <time.h>
//time_t time(time_t *tloc);

#include <zlib.h>
//ZEXTERN gzFile ZEXPORT gzopen OF((const char *path, const char *mode));
//ZEXTERN int ZEXPORT gzputc OF((gzFile file, int c));
//ZEXTERN int ZEXPORT gzgetc OF((gzFile file));
//ZEXTERN int ZEXPORT gzread OF((gzFile file, voidp buf, unsigned len));
//ZEXTERN int ZEXPORT gzwrite OF((gzFile file, voidpc buf, unsigned len));
//ZEXTERN int ZEXPORT gzflush OF((gzFile file, int flush));
//ZEXTERN int ZEXPORT gzclose OF((gzFile file));

#include <errno.h>

#define DEBUGLEVEL 1

struct FileContents
  {
  gzFile FileHandle;
  char *FileName;
  char *FileContents;
  char **FileLines;

  int Size;
  int NumLines;
  int NumOrgLines;
  int isDirty;
  char HashMethod;
  };

struct Row
  {
  char *RowString;
  char *ID;
  signed char Key[4];
  char *Salt;
  char *Value;
  };

size_t strlen (char *s)
  {
  int i;
  i = 0;
  while (s[i] != '\0' && i < (2147483648))
    {i++;}
  return i;
  }

int strcmp(char *s1, char *s2)
  {
  int i;
  i=0;
  while (s1[i] != '\0' && s2[i] != '\0')
    {
    if (s1[i] == s2[i])
      {i++;}
    else if (s1[i] < s2[i])
      {return -1;}
    else
      {return 1;}
    }
  if (s1[i] != '\0')
    {return 1;}
  else if (s2[i] != '\0')
    {return -1;}
  else
    {return 0;}
  }

char *substring(char *string, int start, int length)
  {
  char *tmp;
  int stringlength, i;
  stringlength = strlen(string);

  if (length < 1)
    {
    length = stringlength + length;
    if (length < 0)
      {length = 0;}
    }
  if (start > stringlength)
    {
    start = stringlength;
    length = 0;
    }
  if (start + length > stringlength)
    {length = stringlength - start;}

  tmp=(char *) malloc (length+1);
  if (!tmp) 
    {
    fprintf(stderr, "Malloc error. Probably not enough memory.\n");
    exit(1);
    }
  for (i=0 ; i < length ; i++)
    {tmp[i] = string[start + i];}
  tmp[length]= '\0';

  return tmp;
  }

char *RndString(int length, char *ValidChars)
  {
  int i,val;
  static unsigned int offset = 0;
  //Temp for return value
  char *tmp;
  tmp = (char *) malloc (length + 1);
  if (!tmp)  
    {
    fprintf(stderr, "Malloc error. Probably not enough memory.\n");
    exit(1);
    }
 
  //Seed number for rand()
  srand((unsigned int) offset + time(0) + getpid());
  offset+=2;
 
  //ASCII characters 33 to 126
  for (i=0 ; i< length; i++)
    {
    val = rand() % strlen(ValidChars);
    tmp[i] = ValidChars[val];
    srand(rand());
    }

  tmp[length] = '\0';
 
  return tmp;
  }

int Scramble(signed char key[4], char *myString)
  {
  unsigned int i, x, y;

  for (i=0 ; i < strlen(myString) ; i++)
    {
    if ( myString[i] < 32 || myString[i] > 126 ) {return i + 1;}
    x = i % 255 + 1;
    y = key[0]*x*x*x + key[1]*x*x + key[2]*x + key[3];
    myString[i] = ((y + myString[i] - 35) % 95) + 32;
    }
  return strlen(myString);
  }

int HashLength(char Method)
  {
  switch( Method )
    {
    //Method -1 is geen encryptie
    case '0': return 13; //DES
    case '1': return 22; //MD5
    case '5': return 43; //SHA-256
    case '6': return 86; //SHA-512
    default : return -1;
    }
  }

char *Hash(char Method, char *Salt, char *Value)
  {
  char *Salt2, *Hashed, *Ret;
  int HashLen, SaltLen, RetLen, i, j;
  HashLen=HashLength(Method);

  if (HashLen < 0)
    {return Value;}
  else if (Method == '0')
    {
    Salt2 = Salt;
    }
  else
    {
    Salt2=(char *) malloc(21);
    if (!Salt2)  
      {
      fprintf(stderr, "Malloc error. Probably not enough memory.\n");
      exit(1);
      }
    asprintf(&Salt2, "$%c$%s$", Method, substring(Salt, 0, 16));
    }
  Hashed = crypt(Value, Salt2);
  if (Method != '0')
    {
    SaltLen=-1;
    j=0;
    for (i=0 ; i<strlen(Hashed) ; i++)
      {
      if (Hashed[i] == '$')
        {j++;}
      if (j>2)
        {
        SaltLen=i+1;
        break;
        }
      }
    Ret = substring(Hashed, SaltLen, 0);
    }
  else
    {Ret = Hashed;}
  RetLen = strlen(Ret);
  if (RetLen != HashLen)
    {
#if DEBUGLEVEL>0
      fprintf(stderr, "Length of hash (%i) is other the expected (%i)\n", RetLen, HashLen);
#endif
    }

  free(Salt2);
//  free(Hashed);
  return Ret;
  }

char *SeekRow(char *RowID, char **FileRows, int NumLines)
  {
  int i, LenRowID;
  char *tmp, *Ret;
  Ret = 0;
  LenRowID=strlen(RowID);
#if DEBUGLEVEL>0
  fprintf(stderr, "Searching for Row with RowID=%s.\n", RowID);
#endif
  for (i=0 ; i<NumLines ; i++)
    {
#if DEBUGLEVEL>0
    fprintf(stderr, "%i:", i);
#endif
    tmp = substring(FileRows[i], 0, LenRowID);
#if DEBUGLEVEL>0
    fprintf(stderr, "%s", tmp);
#endif    
    if (strcmp(tmp, RowID) == 0)
      {
      Ret = FileRows[i];
#if DEBUGLEVEL>0
      fprintf(stderr, "=OK\nRowValue=%s.\n", Ret);
#endif    
      break;
      }
    else
      {
#if DEBUGLEVEL>0
      fprintf(stderr, "=NOK\n");
#endif    
      }
    }
  free(tmp);
  return Ret;
  }

int RemoveRow(char *RowID, char **FileRows, int NumLines)
  {
  int i, Ret, LenRowID, Cmp;
  char *tmp;
  LenRowID=strlen(RowID);
  Ret=0;
#if DEBUGLEVEL>0
  fprintf(stderr, "Searching for Row with RowID=%s.\n", RowID);
#endif    
  for (i=0 ; i<NumLines ; i++)
    {
#if DEBUGLEVEL>0
    fprintf(stderr, "%i:", i);
#endif    
    tmp = substring(FileRows[i], 0, LenRowID);
    Cmp = strcmp(tmp, RowID);
//    free(tmp);
#if DEBUGLEVEL>0
    fprintf(stderr, "%s", tmp);
#endif    
    if (Cmp == 0)
      {
      Ret = strlen(FileRows[i]) + 1;
      FileRows[i] = "";
#if DEBUGLEVEL>0
      fprintf(stderr, "=DELETED\n");
#endif    
      break;
      }
    else
      {
#if DEBUGLEVEL>0
      fprintf(stderr, "=NOK\n");
#endif    
      }
    }
  return Ret;
  }

void GenKey(signed char Key[4])
  {

  int i, val;
  static unsigned int offset = 1;

  //Seed number for rand()
  srand((unsigned int) offset + time(0) + getpid());
  offset+=2;
  
  //ASCII characters 33 to 126
  for (i=0 ; i<4 ; i++)
    {
    val = rand() % 94;
    Key[i] = 33 + val;
    srand(rand());
    }
  }

char *GenRow(char *RowID, char *ValidChars)
  {
  char *Row, *RandomText;
  Row = (char *) malloc(strlen(RowID) + 21);
  if (!Row)  
    {
    fprintf(stderr, "Malloc error. Probably not enough memory.\n");
    exit(1);
    }
  RandomText=RndString(20, ValidChars);
  asprintf(&Row, "%s%s", RowID, RandomText);
//  free(RandomText);
  return Row;
  }

char *CalcRow(char *RowID, signed char Key[4], char *Salt)
  {
  char *Row;
  Row = (char *) malloc(strlen(RowID) + strlen(Salt) +5);
  if (!Row)  
    {
    fprintf(stderr, "Malloc error. Probably not enough memory.\n");
    exit(1);
    }
  asprintf(&Row, "%s%c%c%c%c%s", RowID, Key[0], Key[1], Key[2], Key[3], Salt);
  return Row;
  }

char *CalcPRow(char *RowID, char *PW)
  {
  char *Row;
  Row = (char *) malloc(strlen(RowID) + strlen(PW) + 1);
  if (!Row)  
    {
    fprintf(stderr, "Malloc error. Probably not enough memory.\n");
    exit(1);
    }
  asprintf(&Row, "%s%s", RowID, PW);
  return Row;
  }

void help(char *App)
  {
  printf("This is the security enhanced version of the existing gapw.\n");
  printf("Instead of a plain text (ini) file, this version uses hashing of accounts and encryption of passwords.\n");
  printf("The real login must be granted access to the database key (--usergrant) before it can access contents.\n\n");

  printf("Password management:\n");
  printf("-> Write out password: %s [--passwdwrite] --file [path to file] --account [account of password] --password [new password]\n", App);
  printf("-> Read back password: %s [--passwdread] --file [path to file] --account [account of password]\n", App);
  printf("-> Check existence of password: %s --passwdcheck --file [path to file] --account [account of password] [--password [new password]]\n", App);
  printf("   If --password is supplied, then the check includes the password itself. Withoud --password only existence is checked.\n\n");

  printf("Login management:\n");
  printf("-> Grant access to login: %s --usergrant --file [path to file] --login [login to grant access].\n", App);
  printf("-> Revoke access from login: %s --userrevoke --file [path to file] --login [login to revoke access].\n", App);
  printf("-> Check access of login: %s --usercheck --file [path to file] --login [login to check].\n\n", App);

  printf("Optionally you can specify --hashmethod, to manually select another hash method.\n");
  printf("This has only effect on creation of new file (--passwdwrite, with non-existing file).\n");
  printf("The following options are available: 1 (DES), 1 (MD5, default), 5 (SHA-256), 6 (SHA-512).\n");
  printf("Higher value will result in (a little) more security, but larger database files.\n");

  }

int main (int argc, char *argv[])
  {
  //Werking: 
  // In het bestand (de wachtwoorden database) staan 3 belangrijke regels:
  // - De User regel, bestaande uit URowID (43), UKey (4) en USalt (16)
  // - De Entry regel, bestaande uit ERowID (43), EKey (4) en ESalt (16), waarbij EKey en ESalt samen zijn versleuteld middels UKey.
  // - De Password regel, bestaande uit PRowID (43), en het wachtwoord versleuteld middels EKey.
  // De genoemde regels staan altijd in deze volgorde in het bestand.
  //
  //Instellen: PWCrypt [DB File] [user@object] [password]
  // - Als het bestand niet bestaat, dan wordt een leeg bestand aangemaakt.
  // - Het bestand wordt in een array in het geheugen geladen.
  // - De username wordt met DefSalt gehashed. Het resultaat (URowID) identificeert de User regel en deze wordt in het bestand (array) opgezocht.
  // - Als de User regel niet bestaat, dan wordt UKey en USalt gegenereerd, hiermee wordt de userregel opgebouwd 
  //   en deze wordt aan het bestand (array) aan het einde toegevoegd.
  // - De Entry ([user@object]), wordt middels USalt gehashed. Het resultaat (ERowID) identificeert de Entry regel 
  //   en deze wordt in het bestand (array) opgezocht.
  // - Als de Entry regel niet bestaat, dan wordt EKey en ESalt gegenereert, en deze worden samen versleuteld middels uKey. 
  //   Het resultaat wordt achter ERowID geplakt en vormt de Entry regel, welke aan het bestand (array) aan het einde wordt toegevoegd.
  // - Het gespecificeerde Password wordt versleuteld middels de EKey.
  // - ESalt wordt gehashed met USalt. Het resultaat (PRowID) identificeert de Password regel en deze wordt in het bestand (array) opgezocht.
  // - Als de Password regel bestaat, dan wordt de regel verwijderd.
  // - De nieuwe Password regel wordt opgebouwd middels de PRowID en het versleutelde wachtwoord en wordt aan het einde van het bestand (array) toegevoegd.
  // - De array wordt naar het bestand weg geschreven.
  //
  //Uitlezen: PWCrypt [DB File] [user@object]
  // - De username wordt met DefSalt gehashed. Het resultaat (URowID) identificeert de User regel en deze wordt in het bestand opgezocht.
  // - De Userregel bestaat uit URowID (43), UKey (4) en USalt (16).
  // - De Entry ([user@object]), wordt middels USalt gehashed. Het resultaat (ERowID) wordt in het bestand opgezocht en identificeert de Entry regel.
  // - De Entry regel bestaat uit ERowID (43), EKey (4) en ESalt (16), waarbij EKey en ESalt samen zijn versleuteld middels UKey.
  // - Na ontsleutelen van EKey en ESalt wordt ESalt gehashed met USalt tot de PRowID.
  // - Middels PRowID wordt de Password Regel opgezocht.
  // - De Password regel bestaat uit PRowID (43), PWCrypt (rest), waarbij PWCrypt is versleuteld middels EKey.
  // - Na het ontsleutelen van PWCrypt is het wachtwoord beschikbaar.
  //
  int i, j, val, ret, Action=0;
  char *UserName=0, *Entry=0, *Password=0, *Login=0;
  char *defSalt=0, *USalt=0, *ESalt=0;
  char *URowID=0, *ERowID=0, *PRowID=0;
  char *URow=0, *ERow=0, *PRow=0;
  char *tmp=0;
  signed char UKey[4], EKey[4];
  char SaltChars[65];
  int KeyStart, SaltStart;

  struct FileContents KeyFile = {0, 0, 0, 0, 0, 0, 0, 0, '1'};
/*
  gzFile FileHandle;
  char *FileName;
  char *FileContents;
  char **FileLines;

  int Size;
  int NumLines;
  int NumOrgLines;
  int isDirty;
  char HashMethod;
*/


  for (i=1 ; i < argc ; i++)
    {
    if (Action != 0 && (strcmp(substring(argv[i], 8, 0), "--passwd") == 0 || strcmp(substring(argv[i], 6, 0), "--user") == 0))
      {
      fprintf(stderr, "Cannot supply multiple actions (e.a. --passwdwrite --passwdread).\n");
      return 1;
      }

    if (strcmp(argv[i], "--passwdwrite") == 0)
      {Action = 1;}
    else if (strcmp(argv[i], "--passwdread") == 0)
      {Action = 2;}
    else if (strcmp(argv[i], "--passwdcheck") == 0)
      {Action = 3;}
    else if (strcmp(argv[i], "--usergrant") == 0)
      {Action = 4;}
    else if (strcmp(argv[i], "--userrevoke") == 0)
      {Action = 5;}
    else if (strcmp(argv[i], "--usercheck") == 0)
      {Action = 6;}
    else if (strcmp(argv[i], "--bulkload") == 0)
      {Action = 7;}
    else
      {
      if (i+1==argc)
        {
        fprintf(stderr, "Invalid parameter or parameter without value:%s.\n\n", argv[i]);
        help(argv[0]);
        return 1;
        }
      tmp=argv[i+1];
      if (strcmp(argv[i], "--file") == 0)
        {KeyFile.FileName = tmp;}
      else if (strcmp(argv[i], "--hashmethod") == 0)
        {KeyFile.HashMethod=tmp[0];}
      else if (strcmp(argv[i], "--account") == 0)
        {Entry=tmp;}
      else if (strcmp(argv[i], "--password") == 0)
        {Password=tmp;}
      else if (strcmp(argv[i], "--login") == 0)
        {Login=tmp;}
      i++;
      }
    }

  if (!KeyFile.FileName)
    {
    fprintf(stderr, "No passwordfile was specified.\n");
    help(argv[0]);
    return 1;
    }
  if (Password)
    {
    if (Action==0)
      {Action=1;}
    else if (Action!=1 && Action!=3)
      {fprintf(stderr, "Password was supplied without reason...\n");}
    }
  if (Entry)
    {
    if (Action==0)
      {Action=2;}
    else if (Action>3)
      {
      fprintf(stderr, "Account was supplied without reason...\n");
      free(Entry);
      Entry=0;
      }
    }
  if (Login)
    {
    if (Action==0)
      {Action=6;}
    else if (Action<4 || Action == 7)
      {fprintf(stderr, "Login was supplied without reason...\n");}
    }
  if (Action==0)
    {
    fprintf(stderr, "Not enough info was supplied.\n");
    help(argv[0]);
    }

  KeyStart = HashLength(KeyFile.HashMethod);
  if (KeyStart<0)
    {fprintf(stderr, "Invalid value '%c' was specified for parameter --hashmethod.\n", KeyFile.HashMethod);}
  SaltStart = KeyStart + 4;

  // SaltChars bevat alle hoofdletter, kleine letters, getallen '.' en '/'.
  // Dit wordt gebruikt voor het genereren van bijvoorbeeld een Salt.
  for (i=0 ; i<62; i++)
    {
    if (i<10)
      {SaltChars[i] = i+48;} //0-9
    else if (i < 36)
      {SaltChars[i] = i+55;} //A-Z
    else
      {SaltChars[i] = i+61;} //a-z
    }
  SaltChars[62] = '.';
  SaltChars[63] = '/';
  SaltChars[64] = '\0';

  // defSalt bevat de standaard SHA-256 Hash die binnen het programma wordt gehanteerd.
  // Middels deze standaard HASH wordt de gebruikersnaam gehashed tot een unieke User HASH (USalt).
  // USalt bevat de Standaard Salt die verder door deze gebruiker wordt gebruikt voor het maken van SHA-256 Hashes.


  if (KeyFile.HashMethod=='0')
    {
    defSalt = "GP";
    }
  else
    {
    defSalt = (char *) malloc(21);
    if (!defSalt)  
      {
      fprintf(stderr, "Malloc error. Probably not enough memory.\n");
      exit(1);
      }

    defSalt[0] = '$';
    defSalt[1] = KeyFile.HashMethod;
    defSalt[2] = '$';
    for (i=0 ; i<16 ; i++)
      {
      val = (i * 11) % strlen(SaltChars);
      defSalt[i + 3] = SaltChars[val];
      }
    defSalt[19] = '$';
    defSalt[20] = '\0';
    }

#if DEBUGLEVEL>0
  fprintf(stderr, "DefSalt is: %s.\n", defSalt);
#endif    
  UserName = getlogin();
  URowID = Hash(KeyFile.HashMethod, defSalt, UserName);
#if DEBUGLEVEL>0
  fprintf(stderr, "Crypt Username is: %s.\n", URowID);
#endif    

#if DEBUGLEVEL>0
  fprintf(stderr, "Opening file %s.\n", KeyFile.FileName);
#endif    
  KeyFile.FileHandle=gzopen(KeyFile.FileName, "rb");
  if (KeyFile.FileHandle)
    {
#if DEBUGLEVEL>0
    fprintf(stderr, "File %s is opened.\n", KeyFile.FileName);
#endif    
    KeyFile.Size=0;
    j = 1;
    for (i=1 ; i < 5 ; i++)
      {
      KeyFile.Size = KeyFile.Size + gzgetc(KeyFile.FileHandle) * j;
      j = j * 256;
      }
#if DEBUGLEVEL>0
    fprintf(stderr, "Alloc character array %i.\n", KeyFile.Size);
#endif    

    KeyFile.FileContents=malloc(KeyFile.Size+1);
    if (!KeyFile.FileContents)  
      {
      fprintf(stderr, "Malloc error. Probably not enough memory.\n");
      exit(1);
      }
    i=gzread(KeyFile.FileHandle, KeyFile.FileContents, KeyFile.Size+1);
    if ( i != KeyFile.Size)
      {
      if (i>KeyFile.Size)
        {fprintf(stderr, "Corrupted datafile. Uncompressed datasize (at least %i) is larger then was recorded in file header (%i)...\n", i, KeyFile.Size);}
      else
        {fprintf(stderr, "Corrupted datafile. Uncompressed datasize (%i) was not properly recorded in file header (%i)...\n", i, KeyFile.Size);}
      return 2;
      }
    i = sizeof(char*) * (4 + KeyFile.Size / KeyStart);
#if DEBUGLEVEL>0
    fprintf(stderr, "Allocating %i bytes of memory for unencrypted contents of file.\n", i);
#endif    
    KeyFile.FileLines = malloc(i);
    if (!KeyFile.FileLines)  
      {
      fprintf(stderr, "Malloc error. Probably not enough memory.\n");
      exit(1);
      }
    KeyFile.FileLines[0] = KeyFile.FileContents;
    KeyFile.NumLines = 1;
    for (j=0 ; j < KeyFile.Size-1 ; j++)
      {
      if ( KeyFile.FileContents[j] == '\0' && KeyFile.FileContents[j+1] != '\0' )
        {
        KeyFile.FileLines[KeyFile.NumLines] = KeyFile.FileContents + j + 1;
#if DEBUGLEVEL>0
        fprintf(stderr, "Line %i: %s\n", KeyFile.NumLines-1, KeyFile.FileLines[KeyFile.NumLines-1]);
#endif    
        KeyFile.NumLines++;
        }
      }
#if DEBUGLEVEL>1
    fprintf(stderr, "Line %i: %s\n", KeyFile.NumLines-1, KeyFile.FileLines[KeyFile.NumLines-1]);
    fprintf(stderr, "Number of Lines %i.\n", KeyFile.NumLines);
#endif    

    KeyFile.NumOrgLines = KeyFile.NumLines;
    i = sizeof(char*) * (KeyFile.NumLines+3);
#if DEBUGLEVEL>0
    fprintf(stderr, "Realloc %i bytes for lines array (%i lines).\n", i, KeyFile.NumLines+3);
#endif    
    KeyFile.FileLines=realloc(KeyFile.FileLines, i);
    KeyFile.isDirty=0;
    ret = gzclose(KeyFile.FileHandle);
    if (ret != Z_OK)
      {
      fprintf(stderr, "Error %i occurred on closing the file.\n", ret);
      return 1;
      }
    KeyFile.FileHandle = 0;

#if DEBUGLEVEL>0
    fprintf(stderr, "Searching for URow (URowID=%s).\n", URowID);
#endif
    URow = SeekRow(URowID, KeyFile.FileLines, KeyFile.NumLines);

    }
  else if (Action != 1)
    {
    fprintf(stderr, "Could not find file...\n");
    return 3;
    }
  else
    {
    fprintf(stderr, "Could not find file. New file will be created.\n");
    KeyFile.FileLines=malloc(3 * sizeof(char*));
    if (!KeyFile.FileLines)  
      {
      fprintf(stderr, "Malloc error. Probably not enough memory.\n");
      exit(1);
      }
    
    KeyFile.NumLines = 0;
    KeyFile.Size = 0;
    }

  if (URow)
    {
#if DEBUGLEVEL>0
    fprintf(stderr, "URow is found: %s\n", URow);
#endif    
    }
  else
    {
#if DEBUGLEVEL>0
    fprintf(stderr, "Generating URow.\n");
#endif    
fprintf(stderr, "Generating UKey.\n");
    GenKey(UKey);

    USalt=RndString(17, SaltChars);
fprintf(stderr, "Scrambling USalt.\n");
    Scramble (UKey, USalt);
fprintf(stderr, "Calculating URow.\n");
    URow = CalcRow(URowID, UKey, USalt);
fprintf(stderr, "Generating URow finished.\n");

#if DEBUGLEVEL>0
    fprintf(stderr, "URow=%s (generated).\n", URow);
#endif    
    KeyFile.FileLines[KeyFile.NumLines] = URow;
    KeyFile.Size = KeyFile.Size+strlen(URow) + 1;
#if DEBUGLEVEL>0
    fprintf(stderr, "URow added to contents.\n");
#endif    
    KeyFile.NumLines++;
    }

  for (i=0 ; i<4 ; i++)
    {UKey[i] = 0 - URow[i+KeyStart];}
  USalt = substring(URow, SaltStart, 0);
  Scramble (UKey, USalt);

  if (Entry)
    {
#if DEBUGLEVEL>0
    fprintf(stderr, "Calculating ERowID (using USalt %s).\n", USalt);
#endif

    ERowID = Hash(KeyFile.HashMethod, USalt, Entry);

#if DEBUGLEVEL>0
    fprintf(stderr, "Searching for ERow (ERowID=%s).\n", ERowID);
#endif    
    ERow = SeekRow(ERowID, KeyFile.FileLines, KeyFile.NumLines);

    if (ERow)
      {
#if DEBUGLEVEL>0
      fprintf(stderr, "ERow=%s (found).\n", ERow);
#endif
      }
    else
      {
      if (Action == 1)
        {
#if DEBUGLEVEL>0
        fprintf(stderr, "Generating ERow.\n");
#endif
        ERow = GenRow(ERowID, SaltChars);
#if DEBUGLEVEL>0
        fprintf(stderr, "ERow=%s (calculated).\n", ERow);
#endif
        KeyFile.FileLines[KeyFile.NumLines] = ERow;
        KeyFile.Size=KeyFile.Size+strlen(ERow) + 1;
        KeyFile.NumLines++;
        }
      else
        {
        fprintf(stderr, "ERow could not be found.\n");
        return 1;
        }
      }

    ESalt = substring(ERow, SaltStart, 0);
//    Scramble(UKey, ESalt);
    asprintf(&ESalt, "$%c$%s", KeyFile.HashMethod, ESalt);
    PRowID = Hash(KeyFile.HashMethod, USalt, ESalt);
    }

  switch (Action)
  {
  case 1:
    //--passwdread
    {
    //We gaan een wachtwoord weg schrijven.
#if DEBUGLEVEL>0
    fprintf(stderr, "Writing password (Password=%s).\n", Password);
#endif    
    for (i=0 ; i<4 ; i++)
      {EKey[i] = ERow[i+KeyStart];}
#if DEBUGLEVEL>0
    fprintf(stderr, "Scrambling with key: %i, %i, %i, %i.\n", EKey[0], EKey[1], EKey[2], EKey[3]);
#endif    
    Scramble(EKey, Password);
#if DEBUGLEVEL>0
    fprintf(stderr, "Encrypted password=%s.\n", Password);

    fprintf(stderr, "Calculating PRow (using PRowID %s, PW %s).\n", PRowID, Password);
#endif    
    PRow = CalcPRow(PRowID, Password);

    KeyFile.Size = KeyFile.Size - RemoveRow(PRowID, KeyFile.FileLines, KeyFile.NumLines);

    KeyFile.FileLines[KeyFile.NumLines] = PRow;
    KeyFile.Size = KeyFile.Size + strlen(PRow) + 1;
    KeyFile.NumLines++;
    KeyFile.isDirty=1;

    break;
    }
  case 2:
    //--passwdread
    {
#if DEBUGLEVEL>0
    fprintf(stderr, "Searching for password.\n");
#endif
    //We gaan een wachtwoord opzoeken.
    if (!PRowID)
      {
#if DEBUGLEVEL>0
      fprintf(stderr, "Entry not found...\n");
#endif
      return 4;
      }
#if DEBUGLEVEL>0
    fprintf(stderr, "Searching for PRow (PRowID=%s).\n", PRowID);
#endif
    PRow = SeekRow(PRowID, KeyFile.FileLines, KeyFile.NumLines);
    if (PRow)
      {
      Password = substring(PRow,KeyStart,0);
#if DEBUGLEVEL>0
      fprintf(stderr, "Encrypted password is: %s.\n", Password);
#endif
      for (i=0 ; i<4 ; i++)
        {EKey[i] = 0 - ERow[i+KeyStart];}
#if DEBUGLEVEL>0
      fprintf(stderr, "Unscrambling with key: %i, %i, %i, %i.\n", EKey[0], EKey[1], EKey[2], EKey[3]);
#endif
      Scramble(EKey, Password);
      printf("%s\n", Password);
      return 0;
      }
    else
      {
#if DEBUGLEVEL>0
      fprintf(stderr, "Password not found...\n");
#endif
      return 5;
      }
    break;
    }
  case 3:
    {
    //--passwdcheck
#if DEBUGLEVEL>0
    fprintf(stderr, "Password check...\n");
#endif
    break;
    }
  case 4:
    {
#if DEBUGLEVEL>0
    //--usergrant
    fprintf(stderr, "User grant...\n");
#endif
    URowID = Hash(KeyFile.HashMethod, defSalt, Login);
    GenKey(UKey);
    Scramble (UKey, USalt);
    URow = CalcRow(URowID, UKey, USalt);
#if DEBUGLEVEL>0
    //--usergrant
    fprintf(stderr, "URow (for user %s) is %s.\n", Login, URow);
#endif
    KeyFile.FileLines[KeyFile.NumLines] = URow;
    KeyFile.Size = KeyFile.Size + strlen(URow) + 1;
#if DEBUGLEVEL>0
    fprintf(stderr, "URow added to contents.\n");
#endif
    KeyFile.NumLines++;
    KeyFile.isDirty=1;
    break;
    }
  case 5:
    {
#if DEBUGLEVEL>0
    //--userrevoke
    fprintf(stderr, "User revoke...\n");
#endif
    URowID = Hash(KeyFile.HashMethod, defSalt, Login);
    KeyFile.Size = KeyFile.Size - RemoveRow(URowID, KeyFile.FileLines, KeyFile.NumLines);
    KeyFile.isDirty=1;
    break;
    }
  case 6:
    {
#if DEBUGLEVEL>0
    //--usercheck
    fprintf(stderr, "User check...\n");
#endif
    break;
    }
  case 7:
    {
#if DEBUGLEVEL>0
    //--bulkload
    fprintf(stderr, "Bulkload...\n");
#endif
    break;
    }
  }

  if (KeyFile.isDirty)
    {
#if DEBUGLEVEL>0
    fprintf(stderr, "Sorting array.\n");
#endif    
    //Array sorteren (alleen toegevoegde rijen) en naar file schrijven...
    for (i=KeyFile.NumOrgLines ; i<KeyFile.NumLines ; i++)
      {
fprintf(stderr, "Sorting line %i.\n", i);
      tmp = KeyFile.FileLines[i];
      for (j=i-1 ; j>=0 ; j--)
        {
        if (strcmp(KeyFile.FileLines[j], tmp) < 0)
          {
          break;
          }
        KeyFile.FileLines[j+1] = KeyFile.FileLines[j];
        }
      KeyFile.FileLines[j+1] = tmp;
      }
#if DEBUGLEVEL>0
    fprintf(stderr, "Array looks like this:\n");
    for (i=0 ; i < KeyFile.NumLines ; i++)
      {fprintf(stderr, "Line %i: %s\n", i, KeyFile.FileLines[i]);}
#endif

    KeyFile.FileHandle = gzopen(KeyFile.FileName, "wb");

    if (KeyFile.FileHandle)
      {
#if DEBUGLEVEL>0
      fprintf(stderr, "Writing file size (%i) to keyfile %s.\n", KeyFile.Size, KeyFile.FileName);
#endif    
      for (i=1 ; i<5 ; i++)
        {
#if DEBUGLEVEL>0
        fprintf(stderr, "Writing byte %i (%i) to keyfile %s.\n", i, KeyFile.Size % 256, KeyFile.FileName);
#endif    
        gzputc(KeyFile.FileHandle, KeyFile.Size % 256);
        KeyFile.Size = KeyFile.Size / 256;
        }
#if DEBUGLEVEL>0
      fprintf(stderr, "Writing contents to keyfile %s.\n", KeyFile.FileName);
#endif    
      for (i=0 ; i<KeyFile.NumLines ; i++)
        {
        j = strlen(KeyFile.FileLines[i]);
        if (j>0)
          {
#if DEBUGLEVEL>0
          fprintf(stderr, "Writing line %i '%s' to keyfile %s.", i, KeyFile.FileLines[i], KeyFile.FileName);
#endif    
          ret = gzputs(KeyFile.FileHandle, KeyFile.FileLines[i]);
          if (ret < 0) 
            {
#if DEBUGLEVEL>0
            fprintf(stderr, "NOK\n");
#endif
            }
          else
            {
            ret = gzputc(KeyFile.FileHandle, '\0');
            if (ret < 0)
              {
#if DEBUGLEVEL>0
              fprintf(stderr, "NOK\n");
#endif
              }
            else
              {
#if DEBUGLEVEL>0
              fprintf(stderr, "OK\n");
#endif
              }
            }
          }
        }

      gzclose(KeyFile.FileHandle);
      }
    }
  return 0;
  }
